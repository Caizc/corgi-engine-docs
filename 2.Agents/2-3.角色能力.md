# Character Abilities

[Character Abilities](http://corgi-engine-docs.moremountains.com/character-abilities.html)

> 这个页面全面讲解了引擎中包含的各种角色能力（Character Abilities），以及如何创建自定义的能力。

## 一些常识

Character Abilities 脚本赋予你的角色执行动作的能力，无论跳跃、跑动还是按一个按钮，**都是它在起作用**。在引擎之前的版本中，这些都是由一个单一的脚本—— `CharacterBehaviour` 负责处理的。当在一个小游戏中，你的角色只需要走动和跳跃时，当然不需要过度设计。但当有新的特性不断加入时，这里就会变得难以阅读和维护。相互独立的脚本**让系统更易于扩展**，同时让你更加轻松地创建自定义的能力。

## 标准能力

* **Character HorizontalMovement（水平移动）**：这个组件负责处理基础的左右移动、摩擦力和地面检测。在它的 Inspector 视窗中你可以设定标准的移动速度、走路的速度，以及角色跳跃或下落后碰到地面时使用的效果。

* **Character Crouch（潜行）**：这个组件负责处理蹲伏和爬行行为。在它的 Inspector 视窗中你可以设定潜行的速度，以及潜行时碰撞盒（Collider）需不需要调整大小（比如让角色能够爬进隧道）。如果需要，确保你设置了新的尺寸大小。

* **Character Dash（冲撞）**：这个组件让你的角色可以冲撞。在它的 Inspector 视窗中你可以设定冲撞的距离、力度，以及一次冲撞结束后需要冷却多长时间才能开始下一次。

* **Character Dive（俯冲）**：这个组件让你的角色可以俯冲（通过在空中按下冲撞键 + 向下方向键）。在它的 Inspector 视窗中你可以设定它引起的镜头抖动幅度，以及俯冲的速度有多快。

* **Character Dangling（摇摆不定）**：如果角色添加了这个组件，当它面对地面上一个坑洞时就会采取摇摆不定的状态（看起来有些紧张犹豫的样子）。这个检测是通过发射射线（Raycast）完成的，在 Inspector 视窗中可以设置射线的原点和长度。

* **Character Jump（跳跃）**：这个组件负责处理跳跃。在它的 Inspector 视窗中你可以设定以下参数：跳跃的高度，跳跃幅度是否和按下按键的时长成比例，滞空的最小时长（当玩家松开跳跃键之后，角色在下落之前能在空中停留多长时间），跳跃限制，接触地面之前角色可以连跳几次，以及当离开单向平台或移动平台时碰撞（Collision）应该失效多长时间。

* **Character Run（跑动）**：当跑动键被按下时，这个组件让你的角色可以改变速度（在它的 Inspector 视窗中设定）。

* **Character Jetpack（喷气背包）**：角色添加了这个组件之后就可以启用一个喷气背包然后在关卡中飞行。在它的 Inspector 视窗中你可以设定喷气时施加的力，使用的粒子系统特效，各种燃料信息，以及可选的当燃料加满时播放的音效。

* **Character Look Up（向上看）**：这个组件让你的角色在按下向上键且站立在地面时做出往上看的动作。在这种情况下，摄像机向上移动的幅度是在 `CameraController` 的 Inspector 视窗中设定的。

* **Character Grip（抓握）**：角色添加了这个组件之后就可以抓握关卡中带有 `Grip` 组件的物品了。

* **Character Wall Clinging（附着在墙壁上）**：角色添加了这个组件之后就可以附着在墙壁上以减缓下落。在它的 Inspector 视窗中你可以设定减缓的系数（`close to 0` : 超级慢，`1` : 正常下落），以及偏差值（用来处理墙壁上的小凹陷）。

* **Character Walljump（在墙壁上跳跃）**：这个组件让你的角色附着在墙壁上时可以执行一次额外的跳跃。这里你可以设定应用到这次跳跃的力度。

* **Character Ladder（爬梯子）**：这个组件让你的角色可以爬梯子（带有 `Ladder` 组件的对象）。在它的 Inspector 窗口你可以设置角色爬梯子时的速度。

* **Character Push（推）**：这个组件让你的角色可以推动那些可以推的物品。这个组件不是必不可少的，没有它你还是可以推动物体，但它让你可以在推东西的时候播放一个专门的推动动画，并且可以重载默认的推动参数。为了让推动动画生效，你需要为可推动的物品添加一个 `Pushable` 组件。

* **Character Pause（暂停）**：让角色（以及控制它的玩家）可以通过按下暂停键来暂停游戏。

* **Character SlopeOrientation（斜坡上调整面向）**：角色添加了这个组件之后，模型将垂直于它站立的斜坡坡面。你可以设定它转动的速度，允许的最大和最小角度，武器是否也要跟着转动，以及当它在空中时是否需要重置角度。

* **Character Button Activation（激活按钮）**：这个组件让你的角色可以与通过按钮驱动的对象交互（对话区域、开关等）。这里没什么需要设置的。

* **Character Handle Weapon（使用武器）**：这个组件让你的角色可以捡起并使用武器。武器的表现是在 `Weapon` 类中定义的，这个组件只是描述了「手」握武器的行为，而不是武器本身。

## 能力概述

所以一个能力（Ability）究竟都干了些啥？如果你对代码感兴趣，找到答案最简单的方式就是看一看 `CharacterAbility.cs` 类，所有能力都继承于它。我们来快速地过一遍其中的一些方法：

* **Initialization**：顾名思义，在这里基类可以获得角色（Character）或者场景（Scene）的一部分，这些东西通常在子能力中会很有用，比如 `Camera`、`CorgiController` 组件、`InputManager` 等等。子能力一般都会通过这个方法来获取到其他组件和初始参数（连跳次数等）。

* **Animation methods**：使用 `InitializeAnimatorParameters` 方法来注册动画参数，使用 `UpdateAnimator` 方法来更新它们。这里之所以分为两步完成，是为了避免每一帧都要检查各个参数是否存在，这最终会导致性能问题。

* **HandleInput**：被每一个能力重载，用来检测相关的按键和坐标轴的状态。当某个按键被按下或松开时，这个方法将会调用 Ability 脚本中的另一个方法。

* **Early/Process/Late Process ability**：这些方法在状态机的每一次更新（Update）中会被调用。

* **Reset**：这个方法在角色死亡时会被调用，用来重置计数器之类的。

* **Play/Stop Sfx**：这个方法用来触发能力的音效播放。默认情况下每个能力会有 3 个音效（在每个能力的 Inspector 视窗中设定）：一个是能力启用时，一个是能力使用中，一个是能力结束时。你当然可以只使用一个甚至不使用这些音效。如果你创建了自定义的能力，你需要通过调用这些方法来触发音效播放。

## 状态机

Character 组件负责**触发**各种能力（Abilities），这是通过使用**状态机（State Machine）**来实现的。状态机是一种设计模式，本质上它会保存一个当前状态和它的前置状态（如果你对此感到好奇，可以查看源代码或者 API 文档）。默认情况下，一个 Character 使用了两个状态机：

* **MovementState**：在任何能力脚本中通过 `_movement` 属性访问，它代表了角色当前正在执行的行为。

* **ConditionState**：在任何能力脚本中通过 `_condition` 属性访问，它保存了角色的当前状态（正常、死亡、暂停等）。

它运作的方式是，在一个场景开始时，Character 会初始化所有能力，随后在每一帧中调用它们的 `EarlyProcess`、`Process` 和 `LateProcess` 方法，最后在 `OnDeath` 中重置它们。其他状态机实现中通常只是在 `Update` 方法中调用当前状态下的能力，但这个状态机不是。这样做出于多个原因，但最主要是为了**让系统更易于扩展**，而不用重写所有东西或者修改已存在的类。这意味着每一种能力只负责处理它自身的输入，同时防止对它的方法的侵入（通过检测当前状态是否允许这种侵入，例如你不在地面上是不允许走动的）。引擎中包含的大部分能力都没有使用 `EarlyProcess` 或 `LateProcess`，但你如果需要的话可以利用起来。

## 创建自定义能力

创建自定义能力最简单的方式是扩展 `CharacterAbility` 类，就像当前引擎中所有能力实现的方式一样。有必要的话就重载方法（确保你在方法开头调用了基类中的方法）。为了测试新的能力，你只需要将它添加到已有的角色中，它就会自动添加到状态机中，然后像其他能力一样被处理。需要时刻留意的是与其他能力之间的交互，你可能想要扩展其他能力来防止或授权某些状态更改。另外，你的能力可能需要新的状态，你可以在 `CharacterState.cs` 中声明这些状态（在 `MovementStates` 枚举或 `CharacterConditions` 枚举中的任何位置增加，顺序无关）。

你可以看一下现有的那些角色能力类来获得启发，它们就是你正在尝试创建的，同时也是你最终成果的良好示范。这里有一个我用来创建它们的好模板，因为我发现这些方法就是我最经常重载的那些，确保将其中所有的 `TODO` 都替换成你的东西。

```csharp
using UnityEngine;
using System.Collections;
using MoreMountains.Tools;

namespace MoreMountains.CorgiEngine // you might want to use your own namespace here
{
	/// <summary>
	/// TODO_DESCRIPTION
	/// </summary>
	[AddComponentMenu("Corgi Engine/Character/Abilities/TODO_REPLACE_WITH_ABILITY_NAME")]
	public class TODO_NEW_ABILITY_NAME : CharacterAbility
	{
		/// This method is only used to display a helpbox text
		/// at the beginning of the ability's inspector
		public override string HelpBoxText() { return "TODO_HELPBOX_TEXT."; }

		[Header("TODO_HEADER")]
		/// declare your parameters here
		public float randomParameter = 4f;
		public bool randomBool;

		/// <summary>
		/// Here you should initialize our parameters
		/// </summary>
		protected override void Initialization()
		{
			base.Initialization();
			randomBool = false;
		}

		/// <summary>
		/// Every frame, we check if we're crouched and if we still should be
		/// </summary>
		public override void ProcessAbility()
		{
			base.ProcessAbility();
		}

		/// <summary>
		/// Called at the start of the ability's cycle, this is where you'll check for input
		/// </summary>
		protected override void HandleInput()
		{			
			// here as an example we check if we're pressing down
			// on our main stick/direction pad/keyboard
			if (_inputManager.PrimaryMovement.y < -_inputManager.Threshold.y) 				
			{
				DoSomething ();
			}
		}

		/// <summary>
		/// If we're pressing down, we check for a few conditions to see if we can perform our action
		/// </summary>
		protected virtual void DoSomething()
		{
			// if the ability is not permitted
			if ( !AbilityPermitted
				// or if we're not in our normal stance
				|| (_condition.CurrentState != CharacterStates.CharacterConditions.Normal)
				// or if we're grounded
				|| (!_controller.State.IsGrounded)
				// or if we're gripping
				|| (_movement.CurrentState == CharacterStates.MovementStates.Gripping) )
			{
				// we do nothing and exit
				return;
			}

			// if we're still here, we display a text log in the console
			MMDebug.DebugLogTime("We're doing something yay!");
		}

		/// <summary>
		/// Adds required animator parameters to the animator parameters list if they exist
		/// </summary>
		protected override void InitializeAnimatorParameters()
		{
			RegisterAnimatorParameter ("TODO_ANIMATOR_PARAMETER_NAME", AnimatorControllerParameterType.Bool);
		}

		/// <summary>
		/// At the end of the ability's cycle,
		/// we send our current crouching and crawling states to the animator
		/// </summary>
		public override void UpdateAnimator()
		{
			MMAnimator.UpdateAnimatorBool(_animator,"TODO_ANIMATOR_PARAMETER_NAME",(_movement.CurrentState == CharacterStates.MovementStates.Crouching), _character._animatorParameters);			
		}
	}
}
```

-------


